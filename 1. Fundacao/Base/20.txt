===================================================================================================

# => Generics

    Vamos dividir em 2 partes.
    func somaMaisUm[T int](m T) T {
        var n T
        n += 1

        return n
    }

    Generics na linguagem GoLang, introduzidos na versão 1.18, são uma evolução significativa que
    permite escrever código mais flexível e reutilizável. Eles resolvem um problema comum em Go,
    que é a necessidade de criar funções específicas para diferentes tipos de dados.

    Imagine que você deseja escrever uma função para encontrar o valor máximo em uma lista de
    números inteiros, outra função para encontrar o máximo em uma lista de números de ponto
    flutuante e assim por diante. Antes dos generics, isso exigiria várias funções quase idênticas.

    Com os generics, você pode criar uma única função que funciona com diferentes tipos de
    dados. Por exemplo:

    go

    func FindMax[T comparable](list []T) T {
        max := list[0]
        for _, value := range list {
            if value > max {
                max = value
            }
        }
        return max
    }
    Neste exemplo, T é um tipo genérico que pode representar inteiros, floats, ou outros tipos comparáveis.
    Isso torna o código mais limpo e mais fácil de manter, enquanto ainda mantém a segurança de tipos.

    Em resumo, os generics no GoLang simplificam o desenvolvimento, reduzem a duplicação de código e
    mantêm a confiabilidade do tipo. Eles são uma adição valiosa para a linguagem, tornando-a mais
    poderosa e versátil.

...................................................................................................
package main

import "fmt"

func SomaInteiro(m map[string]int) int {
	var operation int = 0
	for _, v := range m {
		operation += v
	}

	return operation
}

func SomaFloat(m map[string]float64) float64 {
	var operation float64 = 0
	for _, v := range m {
		operation += v
	}

	return operation
}

// Criação de Constraint
type MyNumber int
type Number interface {
	~int | ~float64
}

// Essa função pode somar inteiros ou float64 por causa do Generics T
func Soma[T int | float64](m map[string]T) T {
	var operation T
	for _, value := range m {
		operation += value
	}

	return operation
}

/*func Compara[T Number](a T, b T) bool {
	if a == b {
		return true
	}

	return false
}*/

// Da erro por que any pode ser qualquer tipo então no if não temos como confirmar se a e b são do mesmo tipo
/*func Compara[T any](a T, b T) bool {
	if a == b {
		return true
	}

	return false
}*/

func Compara[T comparable](a T, b T) bool {
	if a == b {
		return true
	}

	return false
}

func main() {
	somaUm := map[string]int{"Lucas": 2100, "Ilana": 1000}
	somainteiro := SomaInteiro(somaUm)
	fmt.Printf("O valor mensal é de: %d\n", somainteiro)
	somaDois := map[string]float64{"Lucas": 210.0, "Ilana": 25.52}
	somafloat := SomaFloat(somaDois)
	fmt.Printf("O valor mensal é de: %f\n", somafloat)
	//.....................................................................................
	// Na real é rídiculo criar duas funções iguais só por que os tipos são diferentes né:
	// Então os Generics nos ajudam justamente nessas situações , observe a função Soma
	// Essa função pode somar inteiros ou float64 por causa do Generics -> T :=>
	//.....................................................................................
	// func Soma[T int | float64](m map[string]T) T {
	// 	var operation T
	// 	for _, value := range m {
	// 		operation += value
	// 	}
	//
	// 	return operation
	// }
	//.....................................................................................
	// Se a gente quiser podemos trabalhar com constraints. Que são tipos específicos que a
	// gente cria para ser substituídos
	//.....................................................................................

	// Pelo fato de usar o Generics não importa se colocamos inteiro ou float64 ele irá somar:
	fmt.Println(Soma(somaUm))
	fmt.Println(Soma(somaDois))

	somaTres := map[string]MyNumber{"Lucas": 210, "Ilana": 25}
	fmt.Println(somaTres)

	fmt.Println(Compara(10, 10.0))
}


...................................................................................................
Resultado:
===================================================================================================
